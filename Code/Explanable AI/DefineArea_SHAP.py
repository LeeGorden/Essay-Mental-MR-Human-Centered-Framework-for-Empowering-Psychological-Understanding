# -*- coding: utf-8 -*-
"""
Author: LiGorden
Email: likehao1006@gmail.com
URL: https://www.linkedin.com/in/kehao-li-06a9a2235/
ResearchGate: https://www.researchgate.net/profile/Gorden-Li

Use disorder np map generated by SHAP to create explanatory area
"""
import numpy as np
import math
import matplotlib.pyplot as plt
import gc
import torch
from PIL import Image
from torchvision import transforms


def cal_2d_gaussian(dist_x, dist_y, max_value, sigma=1):
    """
    return: 计算 customized过最大值的 二维正态分布(默认sigma=1, 标准正态)概率密度函数值
    variable: dist_x-在x轴方向上当前点到高斯分布中心点的距离
              dist_y-在y轴方向上当前点到高斯分布中心点的距离
              max_value-customized的标准正态分布的最大值
    """
    dist = np.sqrt(dist_x ** 2 + dist_y ** 2)
    return max_value * math.exp(-dist / (2 * sigma))


if __name__ == '__main__':
    torch.cuda.empty_cache()
    torch.cuda.empty_cache()
    torch.cuda.empty_cache()
    torch.cuda.empty_cache()
    torch.cuda.empty_cache()
    print(gc.collect())
    """
    # 读取保存的explanatory_data, 对应每个样本的shapley value array, 维度为[b, c, h, w]
    explanatory_data = np.load("SHAP_canvas_data_800samples_50background_rand501_train_5.npy")
    explanatory_data = np.absolute(explanatory_data)

    # 计算D1-D10在每个像素上的平均shap value贡献, 这里直接做sum因为结果和mean一样
    explanatory_prob_map = np.zeros([10, 224, 224])
    for i in range(1, 11):
        explanatory_prob = explanatory_data[i]  # explanatory_prob_map初始维度为[b, c, h, w]
        explanatory_prob = explanatory_prob.sum(axis=0)  # explanatory_prob_map维度为[c, h, w]
        explanatory_prob = explanatory_prob.sum(axis=0)  # explanatory_prob_map最后为[h, w]
        explanatory_prob_map[i - 1] = explanatory_prob
    np.save(file="Explanatory_prob_map_train_5.npy", arr=explanatory_prob_map)

    explanatory_prob_map_1 = np.load("Explanatory_prob_map_train_1.npy")
    explanatory_prob_map_2 = np.load("Explanatory_prob_map_train_2.npy")
    explanatory_prob_map_3 = np.load("Explanatory_prob_map_train_3.npy")
    explanatory_prob_map_4 = np.load("Explanatory_prob_map_train_4.npy")
    explanatory_prob_map_5 = np.load("Explanatory_prob_map_train_5.npy")
    explanatory_prob_map_total = explanatory_prob_map_1 + explanatory_prob_map_2 + explanatory_prob_map_3 + \
                                 explanatory_prob_map_4 + explanatory_prob_map_5

    # a = explanatory_prob_map_total[:, 164, 40]
    # b = np.where(a == np.max(a, axis=0))[0][0]

    # 将每个区域按照像素prob分给对应类别
    explanatory_map = np.zeros([224, 224])
    for row in range(224):
        for col in range(224):
            max_prob = 0
            max_prob_class = 0
            for class_num in range(10):
                if explanatory_prob_map_total[class_num][row, col] > max_prob:
                    max_prob_class = class_num + 1  # 将归属标签类标号填入
                    max_prob = explanatory_prob_map_total[class_num][row, col]
            explanatory_map[row, col] = max_prob_class
    explanatory_map = explanatory_map.astype(int)

    # 绘制区域
    plt.figure()
    plt.xticks(np.arange(0, 230, 10))
    plt.yticks(np.arange(0, 230, 10))
    plt.axis('off')
    i = 0
    while i < 224:
        j = 0
        while j < 224:
            num = explanatory_map[i][j]
            if num in [1, 2, 9]:
                num_color = 'b'
            elif num in [3, 4, 5]:
                num_color = 'r'
            elif num in [6, 7, 8, 10]:
                num_color = 'y'
            elif num == 0:
                num_color = 'w'
            plt.annotate(explanatory_map[i][j], xy=(j, 223 - i), xytext=(j, 223 - i), color=num_color)
            j += 10
        i += 10
    plt.show()

    # ------------------------------------------------------------------------------------------------
    # 利用标准正态分布绘制SHAP canvas
    # explanatory_prob_map_gaussian为每个像素点按照高斯分布泛洪后的canvas, 后期会进行裁剪.
    # 这里98 = 49 * 2, 因为最边上的点会以其为中心按照99 * 99(98 + 中线点自己 = 99)的canvas进行高斯泛洪
    explanatory_prob_map_gaussian = np.zeros([10, 224 + 98, 224 + 98])
    for class_ind in range(explanatory_prob_map_total.shape[0]):
        print(class_ind)
        for row in range(explanatory_prob_map_total.shape[1]):
            for col in range(explanatory_prob_map_total.shape[2]):
                center_value = explanatory_prob_map_total[class_ind, row, col]
                if center_value == 0:
                    continue
                # 将泛洪数据对应正态分布数据放到explanatory_prob_map_gaussian对应位置中
                for g_row in range(row, row + 99):
                    for g_col in range(col, col + 99):
                        explanatory_prob_map_gaussian[class_ind, g_row, g_col] += \
                            cal_2d_gaussian(abs(row + 49 - g_row), abs(col + 49 - g_col), center_value, sigma=3)

    np.save(file="Explanatory_prob_map_gaussian_train_1-5_sigma=3.npy", arr=explanatory_prob_map_gaussian)
    """
    explanatory_prob_map_gaussian = np.load("Explanatory_prob_map_gaussian_train_1-5_sigma=1.npy")

    explanatory_prob_map_gaussian = explanatory_prob_map_gaussian[:, 49:49 + 224, 49:49 + 224]
    # 记录每个channel内的最大最小值
    explanatory_prob_map_gaussian_max = [explanatory_prob_map_gaussian[channel].max()
                                         for channel in range(explanatory_prob_map_gaussian.shape[0])]
    explanatory_prob_map_gaussian_min = [explanatory_prob_map_gaussian[channel].min()
                                         for channel in range(explanatory_prob_map_gaussian.shape[0])]
    # 将每个区域按照像素prob分给对应类别(gaussian canvas version)
    explanatory_map_gaussian = np.zeros([224, 224])
    explanatory_map_gaussian_prob = np.zeros([224, 224])  # 记录最大类对应的prob
    for row in range(224):
        for col in range(224):
            max_prob = 0
            max_prob_class = 0
            for class_num in range(10):
                if explanatory_prob_map_gaussian[class_num][row, col] > max_prob:
                    max_prob_class = class_num + 1  # 将归属标签类标号填入
                    max_prob = explanatory_prob_map_gaussian[class_num][row, col]
            explanatory_map_gaussian[row, col] = int(max_prob_class)
            explanatory_map_gaussian_prob[row, col] = (max_prob -
                                                       explanatory_prob_map_gaussian_min[int(max_prob_class - 1)]) / \
                                                      (explanatory_prob_map_gaussian_max[int(max_prob_class - 1)] -
                                                       explanatory_prob_map_gaussian_min[int(max_prob_class - 1)])
    explanatory_map_gaussian = explanatory_map_gaussian.astype(int)
    # 之所以要用1去减是因为后面用np作图的时候数字越小颜色越深
    explanatory_map_gaussian_prob = 1 - explanatory_map_gaussian_prob

    # 绘制区域
    plt.figure()
    plt.xticks(np.arange(0, 230, 10))
    plt.yticks(np.arange(0, 230, 10))
    plt.axis('off')
    i = 0
    while i < 224:
        j = 0
        while j < 224:
            num = explanatory_map_gaussian[i][j]
            if num in [1]:
                num_color = (240 / 255, 255 / 255, 240 / 255)
            elif num in [2]:
                num_color = (230 / 255, 230 / 255, 250 / 255)
            elif num in [3]:
                num_color = (173 / 255, 216 / 255, 230 / 255)
            elif num in [4]:
                num_color = (175 / 255, 238 / 255, 238 / 255)
            elif num in [5]:
                num_color = (255 / 255, 240 / 255, 245 / 255)
            elif num in [6]:
                num_color = (220 / 255, 220 / 255, 220 / 255)
            elif num in [7]:
                num_color = (216 / 255, 191 / 255, 216 / 255)
            elif num in [8]:
                num_color = (255 / 255, 250 / 255, 205 / 255)
            elif num in [9]:
                num_color = (0 / 255, 255 / 255, 255 / 255)
            elif num in [10]:
                num_color = (255 / 255, 228 / 255, 225 / 255)
            plt.annotate(explanatory_map_gaussian[i][j], xy=(j, 223 - i), xytext=(j, 223 - i), color=num_color)
            j += 10
        i += 10
    plt.show(block=True)

    """
    # create gaussian canvas, 有渐变
    # 创建初始白色画布, canvas的维度按照cv中读取np的维度[h, w, c]
    gaussian_canvas = np.ones((224, 224, 3))
    for row in range(explanatory_map_gaussian.shape[0]):
        for col in range(explanatory_map_gaussian.shape[1]):
            # 调整时注意plt.show中为(R, G, B), 而cv中是(B, G, R), 这里设计的背景是给cv用的
            num = explanatory_map_gaussian[row][col]
            if num in [1]:  # 淡蓝色背景
                gaussian_canvas[row, col, 2] = explanatory_map_gaussian_prob[row, col]
            elif num in [2]:  # 淡粉色背景
                gaussian_canvas[row, col, 1] = explanatory_map_gaussian_prob[row, col]
            elif num in [6, 7, 8, 10]:  # 淡黄色背景
                gaussian_canvas[row, col, 0] = explanatory_map_gaussian_prob[row, col]
            # 若谁都不属于, 为白色背景

    plt.figure()
    plt.axis('off')
    plt.imshow(gaussian_canvas)

    np.save(file="Gaussian_canvas_sigma1_jianbian.npy", arr=gaussian_canvas)
    """

    # create gaussian canvas, 无渐变
    # 创建初始白色画布, canvas的维度按照cv中读取np的维度[h, w, c]
    gaussian_canvas = np.ones((224, 224, 3))
    for row in range(explanatory_map_gaussian.shape[0]):
        for col in range(explanatory_map_gaussian.shape[1]):
            # 调整时注意plt.show中为(R, G, B), 而cv中是(B, G, R), 这里设计的背景是给cv用的
            num = explanatory_map_gaussian[row][col]
            if num in [1]:
                gaussian_canvas[row, col, 2] = 240 / 255
                gaussian_canvas[row, col, 1] = 255 / 255
                gaussian_canvas[row, col, 0] = 240 / 255
            elif num in [2]:
                gaussian_canvas[row, col, 2] = 230 / 255
                gaussian_canvas[row, col, 1] = 230 / 255
                gaussian_canvas[row, col, 0] = 250 / 255
            elif num in [3]:
                gaussian_canvas[row, col, 2] = 173 / 255
                gaussian_canvas[row, col, 1] = 216 / 255
                gaussian_canvas[row, col, 0] = 230 / 255
            elif num in [4]:
                gaussian_canvas[row, col, 2] = 175 / 255
                gaussian_canvas[row, col, 1] = 238 / 255
                gaussian_canvas[row, col, 0] = 238 / 255
            elif num in [5]:
                gaussian_canvas[row, col, 2] = 255 / 255
                gaussian_canvas[row, col, 1] = 240 / 255
                gaussian_canvas[row, col, 0] = 245 / 255
            elif num in [6]:
                gaussian_canvas[row, col, 2] = 220 / 255
                gaussian_canvas[row, col, 1] = 220 / 255
                gaussian_canvas[row, col, 0] = 220 / 255
            elif num in [7]:
                gaussian_canvas[row, col, 2] = 216 / 255
                gaussian_canvas[row, col, 1] = 191 / 255
                gaussian_canvas[row, col, 0] = 216 / 255
            elif num in [8]:
                gaussian_canvas[row, col, 2] = 255 / 255
                gaussian_canvas[row, col, 1] = 250 / 255
                gaussian_canvas[row, col, 0] = 205 / 255
            elif num in [9]:
                gaussian_canvas[row, col, 2] = 0 / 255
                gaussian_canvas[row, col, 1] = 255 / 255
                gaussian_canvas[row, col, 0] = 255 / 255
            elif num in [10]:
                gaussian_canvas[row, col, 2] = 255 / 255
                gaussian_canvas[row, col, 1] = 228 / 255
                gaussian_canvas[row, col, 0] = 225 / 255
            # 若谁都不属于, 为白色背景

    plt.figure()
    plt.axis('off')
    plt.imshow(gaussian_canvas)

    np.save(file="Gaussian_canvas_sigma1.npy", arr=gaussian_canvas)

    # ---------------------find out most important pixel to each mental disorders--------------------
    # 坐上角为原点, 横向向右为x+, 纵向向下为y+, 求每个mental disorder重点pixel坐标
    focus_location = np.ones([224, 224, 3])
    for row in range(explanatory_map_gaussian_prob.shape[0]):
        for col in range(explanatory_map_gaussian_prob.shape[1]):
            if explanatory_map_gaussian_prob[row, col] <= 0.25:
                focus_location[row, col] = 0
            elif explanatory_map_gaussian_prob[row, col] <=0.7:
                focus_location[row, col] = 0.8
    plt.figure()
    plt.imshow(focus_location)
    """
    # 将feature位置画在canvas上
    feature_map = Image.open('../../Image/t-SNE/Image_t_SNE_V5.1/Feature_Location.png').convert('RGBA')
    datas = feature_map.getdata()
    newdata = []
    for item in datas:
        print(item)
        if item[0] == 255 and item[1] == 255 and item[2] == 255:
            newdata.append((255, 255, 255, 0))
        else:
            newdata.append(item)
    feature_map.putdata(newdata)
    feature_map.save('11111.png', 'PNG')

    data_transform = transforms.Compose([transforms.ToTensor(), ])
    feature_map = data_transform(feature_map)
    feature_map = feature_map.permute(1, 2, 0)
    feature_map = np.array(feature_map)
    plt.imshow(feature_map)
    """
